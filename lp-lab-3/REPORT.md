#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Федоров А.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     4+        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Поиск в пространстве состояний предназначен для решения задач искусственного интеллекта. Методы поиска подразделяют на два типа: неинформированные методы и информированные методы. Неинформированный метод (слепой поиск или метод грубой силы) не располагает дополнительной информацией о пространстве состояний, может только отличить целевое состояние от любого другого. По сути данный метод просто генерирует все состояния, достижимые из начального и сравнивает их с целевым. Информированный метод использует дополнительную информацию (эвристику) о задаче, отметая заведомо неверные варианты. Данный подход ускоряет нахождение решиня, однако, недостатком такого метода является возможное отсутствие гарантии правильности или оптимальности решения.

Язык Prolog является удобным инструментом для реализации поиска. Помимо того, что поиск в глубину является родным для Prolog'а, возможность Backtracking'а позволяет неявно перебирать состояния, что упрощает реализацию. Также на руку играет синтаксис, где естественным образом можно описать правило перехода с помощью предикатов.

## Задание

## Вариант 4:
"Расстановка мебели". Площадь разделена на шесть квадратов, пять из них заняты мебелью, шестой  -  свободен. Переставитьмебельтак, чтобышкафикреслопоменялисьместами, приэтомникакиедвапредметанемогутстоятьнаодномквадрате.

## Принцип решения

Определяю состояние и правило перехода для пространства состояний. Состоянием буду считать расположение мебели в комнате, а правилом перехода возможность обмена местами пустой клетки с одной из соседних с мебелью (верхняя, нижняя, правая и левая). Для горизонтального и вертикального обмена создам отдельные предикаты `move_lr` и `move_ud`.

```prolog
move(A,B):- move_lr(A,B).
move(A,B):- move_ud(A,B).
```

Для `move_lr` описываю вспомогательный предикат `move_z` для обмена пустой клетки с соседними, если она есть в текущей строке. Соответственно, `move_lr` при неудаче `move_z` применяет его к следующей строке.

```prolog
move_z(['_',X|T],[X,'_'|T]).
move_z([X,'_'|T],['_',X|T]).
move_z([X|T],[X|R]):- move_z(T,R).

move_lr([A|T],[B|T]):- move_z(A,B).
move_lr([A|T],[A|R]):- move_lr(T,R).
```

Аналогично `move_ud` использует вспомогательный предикат `move_h`.

```prolog
move_h(['_'|T],[A|R],[A|T],['_'|R]).
move_h([A|T],['_'|R],['_'|T],[A|R]).
move_h([X|T],[Y|R],[X|T1],[Y|R1]):- move_h(T,R,T1,R1).

move_ud([A,B],[A1,B1]):- move_h(A,B,A1,B1).
```

Для поиска решения буду применять три алгоритма: поиск в глубину, поиск в ширину и поиск с итерационными заглублениями.

Поиск в глубину:

```prolog
dfs(X,Y,P):- dfs1([X],Y,P).
dfs1([X|T],X,[X|T]).
dfs1(P,Y,R):-
    prolong(P,P1),
    dfs1(P1,Y,R).
```

`dfs1` носит с собой список состояний, где конец пути расположен в начале, а начало пути в конце списка. Если начало списка совпадает с целевым состоянием, то предикат завершается успехом. Иначе, предикат переходит во все возможные, еще не достигнутые состояния, в соответствии с правилом перехода. Если перейти уже некуда, то предикат откатывается до предыдущего состояния и пытается перейти в другие уже там. `dfs` - обертка для удобства пользования.

Поиск в ширину:

```prolog
bfs(X,Y,P) :- bfs1([[X]],Y,P).
bfs1([[X|T]|_],X,[X|T]).
bfs1([P|Q1],X,R) :-
    findall(Z, prolong(P,Z),T),
    append(Q1,T,Q0),!,
    bfs1(Q0,X,R).
bfs1([_|T],Y,L) :- bfs(T,Y,L).
```

`bfs1` носит с собой очередь состояний. Пополняется она добавлением всех возможных переходов из состояния первого элемента очереди с последующим удалением его. `bfs` - обертка.

Поиск с итерационными заглублениями:

```prolog
dls(X,Y,P):-
    int(D),
    dls(X,Y,P,D).
dls(X,Y,P,D):- dls1([X],Y,P,D).
int(1).
int(M):-
    int(N),
    M is N+1.
dls1([Y|T],Y,[Y|T],0).
dls1(P,Y,R,D):-
    D>0,
    prolong(P,P1),
    D1 is D-1,
    dls1(P1,Y,R,D1).
```

`dls` - использует вспомогательный предикат `int` для последовательного увеличения глубины обхода на единицу. Сам поиск аналогичен поиску в глубину, за тем исключением, что глубина спуска в графе состояний ограничена. Для исключения повторения одних и тех же путей на разных параметрах глубины, предикат выводит только пути длинной в текущую глубину.

Все три предиката имеют поля для начального состояния, конечного и пути.

Состояние описывается как список из двух списков, каждый из которых имеет по три элемента. Соответственно запрос будет выглядеть так:

```prolog
?- dfs([['П','h','Ф'],['h','_','Ы']], [[_,_,'Ы'],[_,_,'Ф']],R), write_path(R).
```

Предикат `write_path` нужен для удобной печати состояний, так как путь может быть большим, печать его списка урезана. В свою очередь, данный предикат печатает полный путь.

```prolog
write_path([]).
write_path([[A,B]|T]):-
    write(A),
    nl(),
    write(B),
    write(','),
    nl(),
    nl(),
    write_path(T).
```

## Результаты

Для замера времени использовал стандартный предикат `get_time`. Запросы выглядели следующим образом:
```prolog
?- get_time(Start),dfs([['П','h','Ф'],['h','_','Ы']], [[_,_,'Ы'],[_,_,'Ф']],R),length(R,List_size),get_time(Finish),T is Finish-Start.
Start = 1607019844.9717624,
R = [[['П', h, 'Ы'], [h, '_', 'Ф']], [['П', h, 'Ы'], [h, 'Ф', '_']], [['П', h, '_'], [h, 'Ф', 'Ы']], [['П', '_', h], [h, 'Ф', 'Ы']], [['_', 'П', h], [h, 'Ф'|...]], [[h, 'П'|...], ['_'|...]], [[h|...], [...|...]], [[...|...]|...], [...|...]|...],
List_size = 181,
Finish = 1607019844.9854705,
T = 0.013708114624023438.
```

Мебель для удобства чтения состояний изображают символы:
'П' - стол
'h' - стул
'Ы' - кресло
'Ф' - шкаф

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|----------------|---------------------------------|----------------|
| В глубину       |181                             |0.011097431182861328                |
| В ширину        |18                              |0.070659637451171883                |
| ID              |18                              |0.037967443466186521                |

Тест №2
! Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |129                             |0.005741119384765625                |
| В ширину        |19                              |0.065808534622192387                |
| ID              |19                              |0.045290231704711914                |

Поиск в глубину оказался самым быстрым, однако, путь, который он находит далеко не всегда окажется кратчайшим. Поэтому время, затраченное на данный вид поиска никак не зависит от близости решения.

Поиск с итерационными заглублениями оказался чуть медленнее. Совмещая в себе преимущества поиска в глубину и в ширину, данному виду поиска не требуется дополнительная память, как поиску в ширину и в то же время он первым выдаст кратчайший путь. Однако, на запрос следующего ответа данный вид поиска ответит медленнее, чем поиск в ширину, так как продолжит дальше перебор в глубину.

Самым медленным оказался поиск в ширину. Хоть в общем случае он должен быть быстрее, чем поиск с итерационными заглублениями, так как, в отличии от него, проходи все вершины единожды, конкретно в этой задаче он оказался медленнее. Полагаю, это связано с более близким расположением ответа с точки зрения поиска в глубину на глубине 18, 19, чем со стороный поиска в ширину. Но на запрос последующих ответов этот метод поиска отвечал быстрее всех для ответов одинаковой длины, так как следующие ответы лежали близко в очереди и не требовалось снова проходить дерево состояний.

## Выводы

В ходе выполнения лабораторной работы я изучил особенности реализации методов слепого поиска на языке Prolog, научился формализовывать задачи на пространство состояний с правилом перехода. Изучил преимущества и недостатки трех методов неинформированного поиска: поиск в глубину, поиск в ширину и поиск с итерационными заглублениями. Поиск в глубину хорош скоростью нахождения ответа и небольшим расходом памяти (пространственная сложность O(h), где h - длина пути), плох не оптимальностью найденного пути. Поиск в глубину хорош там, что найдет первым кратчайший путь, плох большим расходом памяти (сложностная оценка O(b'), где b' - степень ветвления дерева). Поиск с итерационными заглублениями хорош совмещением преимуществ двух вышеуказанных методов поиска, но плох повторным перебором уже рассмотренных путей при переходе на следующее значение глубины, но это не влияет на сложность алгоритма, что делает его ненамного хуже поиска в глубину в плане затрат по времени.

Итак, поиск в глубину хорош, если длина пути не важна, поиск в ширину хорош, когда необходимо быстро найти почти одной длины, а поиск с итерационными заглублениями хорош, когда требуется найти кратчайший путь и при этом не расходуя много памяти.

Конкретно в данной задаче оптимальным алгоритмом оказался поиск с итерационными заглублениями, так как за несильно большее время он, в отличие от поиска в глубину, выдал кратчайший путь.




